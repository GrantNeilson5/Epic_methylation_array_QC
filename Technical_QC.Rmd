---
title: "Technical QC" 
author: "G Neilson"
output: html_document
params: 
  Name: Portland_Batch2
  SampleSheet: Sample_Sheet_Batch2.csv
  PathToProjectFolder: /mnt/data1/Array_Projects/Portland_Samples/Batch2
  Mset: Batch2Portland_Mset.rdat
  RGset: Batch2Portland_RGset.rdat
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



##Introduction
This is an R Markdown document for the weeekly Quality Control (QC) check from the Illumina EPIC microarray data from the `r params$Name` 

Samples are not removed after each QC step, but a record is kept of samples which have already failed previous steps and the results of all tests are provided as output.

##Loading data
```{r loadingdata, include=FALSE}
library(methylumi)
library(wateRmelon)
require(gdata)
library(minfi)
library(ggplot2)
library(gdata)
require(gridExtra)
require(IlluminaHumanMethylationEPICmanifest)
library(tidyr)
library(dplyr)
library(IlluminaHumanMethylationEPICanno.ilm10b2.hg19)

setwd(params$PathToProjectFolder)

SampleSheet<-read.csv(file = params$SampleSheet, stringsAsFactors = FALSE)
SampleSheet$Sex <- as.factor(SampleSheet$Sex)

rownames(SampleSheet) <- SampleSheet$Basename

SampleSheet$Empty <- is.na(SampleSheet$Sample_ID) 
SampleSheet$Control <- SampleSheet$Sample_ID == "Meth_Control"


## make chip name full (R often changes this to scientific notation)
SampleSheet$Basename2<-SampleSheet$Basename
SampleSheet<-separate(data = SampleSheet, col = Basename2, into = c("SentrixID", "Position"), sep="_")
```

```{r Making Mset and RGset, echo=FALSE, message=FALSE}
setwd(params$PathToProjectFolder)
#First copy the idats over to knight using "scp 201114400019/*.idat gNeilson@knight.ex.ac.uk:/mnt/data1/BDR/Methylation/idats/" and then use "chmod a+r *.idat" to change the permissions so all users can read the files
idatPath<-c("/mnt/data1/Array_Projects/Idats")

#For most steps we need the idats as a methylumiSet but for some we need an RGset
#These take a while to create - so saving as R objects to load faster next time

if(file.exists(file=  params$Mset)){
  load(file = params$Mset)
  print(paste("Loading Mset:", params$Mset))
} else {
msetEPIC <- readEPIC(idatPath=idatPath, barcodes=SampleSheet$Basename, parallel = FALSE, force=T)
save(msetEPIC, file = paste(params$PathToProjectFolder, params$Mset, sep=""))
print(paste("Mset created and saved as", params$Mset))
}

if(file.exists(file= params$RGset)){
  load(file= params$RGset)
  print(paste("Loading RGset:", params$RGset))
} else{
RGset <- read.metharray.exp(base = idatPath, targets = SampleSheet, force = TRUE)
save(RGset,file = paste(params$PathToProjectFolder, params$RGset, sep=""))
print(paste("RGset created and saved as", params$RGset))
}
```

###Study Information
**Study:** `r params$Name`

**Arrays ran by:** `r SampleSheet[1,"Name_lab"]`, The University of Exeter Medical School

**Array used:** Illumina EPIC microarray v1.0

**QC done by:**`r SampleSheet[1,"Name_QC"]`, The University of Exeter Medical School

**Date of QC:** `r format(Sys.Date(), format="%d %B %Y")`

**Sample ages:** `r range(SampleSheet$Age, na.rm = TRUE)`

**Sample Tissue:** `r unique(SampleSheet$Organ)` 

##QC Information 



```{r createQCmetrics, echo=FALSE}
betas <- betas(msetEPIC)
SampleSheet <- SampleSheet[order(rownames(SampleSheet)),]
msetEPIC <- msetEPIC[,order(colnames(msetEPIC))]
if(print(identical(rownames(SampleSheet), colnames(msetEPIC))) ==TRUE){
  print("Mset and Sample sheet  match")
} else{
  print("Mset and Sample Sheet do not match")
  exit()
}


#QC metrics can be be bound on to the end of a copy of the sample sheet 
QCmetrics<-SampleSheet

#SamplesFail will be our boolean record of which samples have already failed
SamplesFail<-as.logical(rep("FALSE", nrow(SampleSheet)))
#Entries will be changed to TRUE as samples fail 

Stepsummary<-as.data.frame(matrix(ncol=0, nrow=2))
rownames(Stepsummary)<-c("Failed This Step", "Total Failed")

```


The phenotype file containing the sample information was loaded into R. Then the methylation data for the `r nrow(SampleSheet)` samples were loaded into a methylumiset. This contains `r nrow(SampleSheet[SampleSheet$Sample_ID != "Meth_Control",])` `r params$Name` and `r nrow(SampleSheet[SampleSheet$Sample_ID == "Meth_Control",])` fully methylated control samples.

##Check Signal Intensities
The intensity check is the biggest indicator of sample quality. The median methylated signal intensity and unmethylated signal intensity for each sample is calculcated.

```{r medianintensities, include=FALSE}
m_intensities<-methylated(msetEPIC)
u_intensities<-unmethylated(msetEPIC)
M.median<-apply(m_intensities, 2, median)
U.median<-apply(u_intensities, 2, median)
QCmetrics<-cbind(SampleSheet,M.median, U.median)
```

A histogram and scatter plot of the resulting data are plotted to visualise the data quality. Samples are coloured by methylation plate or institute, to make sure there are no batch effects.

```{r plotintensities, echo=FALSE}
# coloured by institute
plotfactor<-factor(SampleSheet$Institute, levels=c(unique(SampleSheet$Institute))) 
par(mfrow = c(1,2))
hist(M.median, xlab = "Median M intensity", main="Histogram of Median Methylated Intensities", cex.main=0.7)
hist(U.median, xlab = "Median U intensity", main="Histogram of Median Unmethylated Intensities", cex.main=0.7)
par(mfrow = c(1,1))
plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col = rainbow(nlevels(plotfactor))[factor(plotfactor)], main="Scatter plot of Signal Intensities coloured by Institue")
par(xpd=TRUE)
legend("topright", levels(factor(plotfactor)), col = rainbow(nlevels(plotfactor)), pch = 10, cex=0.5)

#coloured by plate
plotfactor<-factor(SampleSheet$Plate, levels=c(unique(SampleSheet$Plate)))
par(mfrow = c(1,1))
plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col = rainbow(nlevels(plotfactor))[factor(plotfactor)], main="Scatter plot of Signal Intensities coloured by plate")
par(xpd=TRUE)
legend("topright", levels(factor(plotfactor)), col = rainbow(nlevels(plotfactor)), pch = 10, cex=0.5)

## Coloured By Ethnicity
plotfactor<-factor(SampleSheet$Ethnicity, levels=c(unique(SampleSheet$Ethnicity)))
par(mfrow = c(1,1))
plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col = rainbow(nlevels(plotfactor))[factor(plotfactor)], main="Scatter plot of Signal Intensities coloured by Ethnicity")
par(xpd=TRUE)
legend("topright", levels(factor(plotfactor)), col = rainbow(nlevels(plotfactor)), pch = 10, cex=0.5)

##Coloured by Organ
plotfactor<-factor(SampleSheet$Organ, levels=c(unique(SampleSheet$Organ)))
par(mfrow = c(1,1))
plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col = rainbow(nlevels(plotfactor))[factor(plotfactor)], main="Scatter plot of Signal Intensities coloured by Organ")
par(xpd=TRUE)
legend("topright", levels(factor(plotfactor)), col = rainbow(nlevels(plotfactor)), pch = 10, cex=0.5)


##Coloured by SentrixID
plotfactor<-factor(SampleSheet$SentrixID, levels=c(unique(SampleSheet$SentrixID)))
par(mfrow = c(1,1))
plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col = rainbow(nlevels(plotfactor))[factor(plotfactor)], main="Scatter plot of Signal Intensities coloured by SentrixID")
par(xpd=TRUE)
legend("topright", levels(factor(plotfactor)), col = rainbow(nlevels(plotfactor)), pch = 10, cex=0.5)

##Coloured by Phenotype
plotfactor<-factor(SampleSheet$Phenotype, levels=c(unique(SampleSheet$Phenotype)))
par(mfrow = c(1,1))
plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col = rainbow(nlevels(plotfactor))[factor(plotfactor)], main="Scatter plot of Signal Intensities coloured by Phenotype")
par(xpd=TRUE)
legend("topright", levels(factor(plotfactor)), col = rainbow(nlevels(plotfactor)), pch = 10, cex=0.5)



```

The signal intensities are okay for these samples. 
 
To further investigate the plates we can plot heatmaps of the intensities, shown below.

```{r intensityheatmap, echo=FALSE}
QCmetrics$position<-factor(QCmetrics$Position)
QCmetrics$SentrixID<-factor(QCmetrics$SentrixID, levels=rev(unique(QCmetrics$SentrixID))) #keeps the levels of the factor in current order rather than sorting numerically/alphabetically, also reverses this order as heatmaps plot bottom to top

plates<-unique(QCmetrics$Plate)


#extract the legend (using a function found online)
g_legend<-function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    legend
}

for(plate in plates){
  samples<-QCmetrics[which(QCmetrics$Plate == plate),]
  control<-samples[samples$Control,]

  plateHeatmap <- ggplot(data=samples, aes(x=Position, y=SentrixID)) +
    scale_fill_gradientn(colours=colorRamps::matlab.like(100), limits=c(min(QCmetrics$U.median),max(QCmetrics$M.median))) +
    labs(x="", y="") +
    theme_minimal() + 
    coord_equal() +
    theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 90, hjust=1))
  
  plot1 <- plateHeatmap +
    ggtitle("Median Methylated Intensity") +
    geom_tile(aes(fill=M.median), colour = "white") +
    geom_point(data=control, aes(x=control$Position, y=control$SentrixID)) +
    theme(legend.position = "none")
  
  plot2 <- plateHeatmap +
    ggtitle("Median Unmethylated Intensity") +
    geom_tile(aes(fill=U.median), colour = "white") +
    geom_point(data=control, aes(x=control$Position, y=control$SentrixID)) +
    theme(legend.position = "none")
  
  legendplot<-plateHeatmap + 
    geom_tile(aes(fill=U.median), colour = "white") +
    labs(fill="Intensity", alpha="Control") +
    geom_point(data=control, aes(x=control$Position, y=control$SentrixID, alpha=control$Control)) +
    scale_alpha_manual(values=c(1,1,1)) + 
    guides(alpha = guide_legend(override.aes = list(colour="black", pch=16)))
    
  legend<-g_legend(legendplot)
  
  grid.arrange(plot1, plot2, legend, ncol=3, widths=c(3/7, 3/7, 1/7), top=paste("", plate))
}
```
Intensities from the various control probes on the array are plotted to check the experiment has worked as expected. 


```{r Array statistics, echo= FALSE}

## Plotting control probes from fully methylated controls
RGset_controls <- RGset[,which(RGset@colData@listData$Basename %in% rownames(control))]
par(mfrow=c(2,2))
controlStripPlot(RGset_controls, controls = "BISULFITE CONVERSION I")
controlStripPlot(RGset_controls, controls = "BISULFITE CONVERSION II")
controlStripPlot(RGset_controls, controls = "EXTENSION")
controlStripPlot(RGset_controls, controls = "STAINING")
controlStripPlot(RGset_controls, controls = "HYBRIDIZATION")
controlStripPlot(RGset_controls, controls = "TARGET REMOVAL")
controlStripPlot(RGset_controls, controls = "SPECIFICITY I")
controlStripPlot(RGset_controls, controls = "SPECIFICITY II")
controlStripPlot(RGset_controls, controls = "NON-POLYMORPHIC")
controlStripPlot(RGset_controls, controls = "NEGATIVE")
controlStripPlot(RGset_controls, controls = "NORM_A")
controlStripPlot(RGset_controls, controls = "NORM_T")
controlStripPlot(RGset_controls, controls = "NORM_C")
controlStripPlot(RGset_controls, controls = "NORM_G")

```

The fully methylated controls have their intensities logged, and saved to ComparingFullyMethylatedControls.csv for cross-study comparisions of the scanner.

```{r removecontrols, include=FALSE}
Previous_FMpheno <- read.csv("/mnt/data1/Array_Projects/Methylated_Controls/ComparingFullyMethylatedControls.csv")
FMpheno<-QCmetrics[SampleSheet$Control,c("Basename", "SentrixID", "Position", "M.median", "U.median")]
Betas_meth_control <- betas[,SampleSheet$Control]

# 
# #we also want to manually find the time they were processed (this is the time stamp of the idats on the MDrive)
meth_controls <- SampleSheet[SampleSheet$Control, c("Basename")]

times<- SampleSheet[which(SampleSheet$Basename %in% rownames(control)), c("Date_array_run", "Date_Bisulphite_con")]

# add some study info and save
info<-data.frame(Study=rep(params$Name,nrow(FMpheno)), iDAT_Location=rep(idatPath, nrow(FMpheno)))
FMpheno<-cbind(info, times, FMpheno)
FMpheno <- rbind(Previous_FMpheno, FMpheno)
write.csv(FMpheno, "/mnt/data1/Array_Projects/Methylated_Controls/ComparingFullyMethylatedControls.csv",row.names=FALSE)


#remove from all variables
M.median<-M.median[!SampleSheet$Control]
U.median<-U.median[!SampleSheet$Control]
msetEPIC<-msetEPIC[,!SampleSheet$Control]
RGset<-RGset[,!SampleSheet$Control]
SamplesFail<-SamplesFail[!SampleSheet$Control]
QCmetrics<-QCmetrics[!SampleSheet$Control,]
SampleSheet<-SampleSheet[!SampleSheet$Control,]


## remove the empty 'samples'
M.median<-M.median[!SampleSheet$Empty]
U.median<-U.median[!SampleSheet$Empty]
msetEPIC<-msetEPIC[,!SampleSheet$Empty]
RGset<-RGset[,!SampleSheet$Empty]
SamplesFail<-SamplesFail[!SampleSheet$Empty]
QCmetrics<-QCmetrics[!SampleSheet$Empty,]
SampleSheet<-SampleSheet[!SampleSheet$Empty,]

```

Although signal intensity is the largest predictor of sample quality, the threshold at which to exclude samples can vary from experiment to experiment - for example, signal intensities can vary slightly depending on tissue type or DNA extraction method. Samples which clearly deviate from the main cluster on the signal intensity plots should be removed. 

```{r}

lowintensitysamples<-which(M.median < 800 | U.median < 800)
```

```{r scatter500, echo=FALSE}
Intensity<-rep("OK", nrow(SampleSheet))
Intensity[lowintensitysamples] <-"LowIntensity"

plotfactor<-as.factor(Intensity)

plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col=rainbow(2)[factor(plotfactor)])
abline(v = 800, col = "red")
abline(h = 800, col = "red")
legend("topleft", levels(factor(plotfactor)), pch = 16, col = rainbow(2))
```


```{r updateQCmetrics1, include=FALSE}
intensPASS <- M.median > 500
SamplesFail[which(Intensity=="LowIntensity")]<-TRUE
QCmetrics<-cbind(QCmetrics, Intensity, intensPASS)
Step1<-c(sum(Intensity=="LowIntensity"),sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step1)
```


```{r Stepsummary1}
print(Stepsummary)
```

##Bisulphite Conversion
A bisulphite conversion statistic for each sample was calculated, and a histogram of the results plotted.

```{r bisulphiteconversion, echo=FALSE}
Bisulphite<-bscon(msetEPIC)
hist(Bisulphite, xlab = "Median % BS conversion", main = "Histogram of Bisulphite Converstion Statistics")
```

Samples with a conversion < 80% fail the QC, so with this threshold `r sum(Bisulphite<80)` samples fail the QC, and will be removed at a later stage.


```{r updateQCmetrics2, include=FALSE}
QCmetrics<-cbind(QCmetrics, Bisulphite)
SamplesFail[which(Bisulphite<80)]<-TRUE
Step2<-c(sum(Bisulphite<80, na.rm=T),sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step2)


bisulphite_fail <- QCmetrics[SamplesFail,]
```

```{r Stepsummary2}
print(Stepsummary)
```




##Check Sex
A principal component analysis of the methylation data can be used to predict the sex of the samples.

The principal components are calculated, and the two which correlate most with sex are found. These can be used to generate a scatter plot where the sexes are clearly separated.


```{r sex check, echo = FALSE}

GRset <- mapToGenome(RGset)

## check sex
# idenitfy X chromosome probes
if(!"PredictedSex" %in% colnames(QCmetrics)){	
	x.probes <- which(seqnames(GRset) == "chrX")
  y.probes <- which(seqnames(GRset) == "chrY")
	ints.auto<-getMeth(GRset)[c(x.probes, y.probes),]+getUnmeth(GRset)[c(x.probes, y.probes),]
	ints.X<-getMeth(GRset)[x.probes,]+getUnmeth(GRset)[x.probes,]
	ints.Y<-getMeth(GRset)[y.probes,]+getUnmeth(GRset)[y.probes,]
	x.cp<-colMeans(ints.X, na.rm = TRUE)/colMeans(ints.auto, na.rm = TRUE)
	y.cp<-colMeans(ints.Y, na.rm = TRUE)/colMeans(ints.auto, na.rm = TRUE)
	## base prediction on y chromosome
	predSex.y<-rep(NA, length(y.cp))
	predSex.y[which(y.cp > 1 & intensPASS == TRUE)]<-"M"
	predSex.y[which(y.cp < 1 & intensPASS == TRUE)]<-"F"
	## base prediction on x chromosome
	predSex.x<-rep(NA, length(x.cp))
	predSex.x[which(x.cp < 1 & intensPASS == TRUE)]<-"M"
	predSex.x[which(x.cp > 1 & intensPASS == TRUE)]<-"F"
	## check for consistent prediction
	PredictedSex<-rep(NA, length(x.cp))
	PredictedSex[which(predSex.x == predSex.y)]<-predSex.x[which(predSex.x == predSex.y)]
	QCmetricsSex<-cbind(QCmetrics,x.cp,y.cp,predSex.x, predSex.y, PredictedSex)
}

plot(QCmetricsSex$x.cp, QCmetricsSex$y.cp, col = QCmetricsSex$Sex, xlab = "X chromosome", ylab = "Y chromosome", pch = 16)
abline(v = 1)
abline(h = 1, pch = 16)
```



```{r updateQCmetrics3, include=FALSE}
SampleSheet$Sex <- as.character(SampleSheet$Sex)
ReportedSex<-SampleSheet$Sex
QCmetrics<-cbind(QCmetrics, PredictedSex)
QCmetrics$MismatchSex<-PredictedSex!=ReportedSex
SamplesFail[which(PredictedSex!=ReportedSex)]<-TRUE
Step3<-c(length(which(PredictedSex!=ReportedSex)),sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step3)
```

Here `r sum(PredictedSex!=ReportedSex, na.rm=T)` number of sampless predicted sex does not match their reported sex. These samples fail the QC according to the findGenderPC function and, and will be removed.

```{r Stepsummary3}
print(Stepsummary)
```


##Age Prediction
The age of samples can be predicted from their methylation data using Horvath's Coefficients and compared to the samples' reported ages. 

However, this can be inaccurate and so it is used as a quality check and not as a reason to remove samples. Therefore, the following plot only contains samples which have passed the previous QC steps.

```{r dnamage, echo=FALSE}

QCmetrics$Age <- as.numeric(as.character(QCmetrics$Age))
betas <- betas[,rownames(QCmetrics)]
identical(rownames(QCmetrics), colnames(betas))
PredictedAge<-agep(betas)
ReportedAge<-QCmetrics$Age
model<-lm(ReportedAge~PredictedAge)

plot(PredictedAge[!SamplesFail], QCmetrics$Age[!SamplesFail], xlab = "Predicted", ylab = "Reported", main="Reported Age against Predicted Age", pch=16, col="purple")
abline(model)
QCmetrics<-cbind(QCmetrics, PredictedAge)

cor.test(QCmetrics$Age, QCmetrics$PredictedAge)

```


## Check phenotype distribution across plate

It is important for the study design to have equal distribution of phenotypes (e.g Case/Control, Sex).A Chisq to check that the phenotypes are spread randomly is summarised in the table, each value representing p.value.

```{r plate design, warning=FALSE, echo=FALSE}
QCmetrics$plate_row <- substring(QCmetrics$Plate_Location,1,1)
QCmetrics$plate_col <- substring(QCmetrics$Plate_Location,2,3)
plates = unique(QCmetrics$Plate)

chisq_results <- matrix(NA, nrow = 4, ncol = length(plates))
colnames(chisq_results) <- plates
rownames(chisq_results) <- c('Sex_Row','Sex_Col','Case/Con_Row','Case/Con_Col')
for (i in 1:length(plates)){
  plate = plates[i]
  QCmetricsplate <- QCmetrics[QCmetrics$Plate == plate, ]
  QCmetricsplate$Sex <- as.character(QCmetricsplate$Sex)
  #Sex by Row
  tbl <- table(QCmetricsplate$Sex, QCmetricsplate$plate_row)
  tbl_ch <- chisq.test(tbl)
  chisq_results[1,i] <- signif(tbl_ch$p.value,3)
  
  #Sex by Col
  tbl <- table(QCmetricsplate$Sex, QCmetricsplate$plate_col)
  tbl_ch <- chisq.test(tbl)
  chisq_results[2,i] <- signif(tbl_ch$p.value,3)
  
  #Pheno by Row
  tbl <- table(QCmetricsplate$Phenotype, QCmetricsplate$plate_row)
  tbl_ch <- chisq.test(tbl)
  chisq_results[3,i] <- signif(tbl_ch$p.value,3)
  
  #Pheno by Col
  tbl <- table(QCmetricsplate$Phenotype, QCmetricsplate$plate_col)
  tbl_ch <- chisq.test(tbl)
  chisq_results[4,i] <-  signif(tbl_ch$p.value,3)
}
chisq_results
```

From this technical QC, `r sum(SamplesFail)` samples have failedand `r sum(!SamplesFail)` samples have passed.

```{r Stepsummary4}
print(Stepsummary)
```
